<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultipleSeriesProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">psi-probe-core</a> &gt; <a href="index.source.html" class="el_package">psiprobe.beans.stats.providers</a> &gt; <span class="el_source">MultipleSeriesProvider.java</span></div><h1>MultipleSeriesProvider.java</h1><pre class="source lang-java linenums">/**
 * Licensed under the GPL License. You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 * THIS PACKAGE IS PROVIDED &quot;AS IS&quot; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
 * WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
package psiprobe.beans.stats.providers;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import javax.servlet.http.HttpServletRequest;
import org.jfree.data.xy.DefaultTableXYDataset;
import org.jfree.data.xy.XYDataItem;
import psiprobe.model.stats.StatsCollection;

/**
 * Retrieves stats series with names that start with the statNamePrefix. Either all matching series
 * or only &quot;top&quot; N ones can be retrieved. Determines top series by comparing max moving avg values.
 * Derrives legend entries from series names by removing the statNamePrefix. Ignores series param
 * (sp) and legend (s...l) request parameters.
 */
<span class="fc" id="L30">public class MultipleSeriesProvider extends AbstractSeriesProvider {</span>

  /** The stat name prefix. */
  private String statNamePrefix;

  /** The top. */
  private int top;

  /** The moving avg frame. */
  private int movingAvgFrame;

  /**
   * Gets the stat name prefix.
   *
   * @return the stat name prefix
   */
  public String getStatNamePrefix() {
<span class="fc" id="L47">    return statNamePrefix;</span>
  }

  /**
   * Sets the stat name prefix.
   *
   * @param statNamePrefix - only series with names that start with statNamePrefix are retrieved.
   */
  public void setStatNamePrefix(String statNamePrefix) {
<span class="fc" id="L56">    this.statNamePrefix = statNamePrefix;</span>
<span class="fc" id="L57">  }</span>

  /**
   * Gets the top.
   *
   * @return the top
   */
  public int getTop() {
<span class="fc" id="L65">    return top;</span>
  }

  /**
   * Sets the top.
   *
   * @param top - the number of top series to retrieve. If this value is greater than 0, only this
   *        many series with the greatest max moving avg values are retrieved.
   */
  public void setTop(int top) {
<span class="fc" id="L75">    this.top = top;</span>
<span class="fc" id="L76">  }</span>

  /**
   * Gets the moving avg frame.
   *
   * @return the moving avg frame
   */
  public int getMovingAvgFrame() {
<span class="fc" id="L84">    return movingAvgFrame;</span>
  }

  /**
   * Sets the moving avg frame.
   *
   * @param movingAvgFrame - if this value is greater than 0, a moving avg value is calculated for
   *        every series using every Nth value, where N % movingAvgFrame == 0. Top series are
   *        identified based on a max moving avg value of each series. If the movingAvgFrame equals
   *        to 0, top series are determined based on a simple avg of all series values.
   */
  public void setMovingAvgFrame(int movingAvgFrame) {
<span class="fc" id="L96">    this.movingAvgFrame = movingAvgFrame;</span>
<span class="fc" id="L97">  }</span>

  @Override
  public void populate(DefaultTableXYDataset dataset, StatsCollection statsCollection,
      HttpServletRequest request) {

<span class="nc" id="L103">    Map&lt;String, List&lt;XYDataItem&gt;&gt; statMap = statsCollection.getStatsByPrefix(statNamePrefix);</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">    boolean useTop = getTop() &gt; 0 &amp;&amp; getTop() &lt; statMap.size();</span>
<span class="nc" id="L105">    List&lt;Series&gt; seriesList = new ArrayList&lt;&gt;(statMap.size());</span>

<span class="nc bnc" id="L107" title="All 2 branches missed.">    for (Map.Entry&lt;String, List&lt;XYDataItem&gt;&gt; entry : statMap.entrySet()) {</span>
<span class="nc" id="L108">      Series ser = new Series(entry);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (useTop) {</span>
<span class="nc" id="L110">        ser.calculateAvg();</span>
      }
<span class="nc" id="L112">      seriesList.add(ser);</span>
<span class="nc" id="L113">    }</span>

<span class="nc bnc" id="L115" title="All 2 branches missed.">    if (useTop) {</span>
      // sorting stats by the avg value to identify the top series
<span class="nc" id="L117">      Collections.sort(seriesList, new Comparator&lt;Series&gt;() {</span>
        @Override
        public int compare(Series s1, Series s2) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">          return Double.compare(s1.avg, s2.avg) == 0 ? s1.key.compareTo(s2.key)</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">              : Double.compare(s1.avg, s2.avg) &gt; 0 ? -1 : 1;</span>
        }
      });

      // keeping only the top series in the list
<span class="nc bnc" id="L126" title="All 2 branches missed.">      for (ListIterator&lt;Series&gt; i = seriesList.listIterator(getTop()); i.hasNext();) {</span>
<span class="nc" id="L127">        i.next();</span>
<span class="nc" id="L128">        i.remove();</span>
      }
    }

    // sorting the remaining series by name
<span class="nc" id="L133">    Collections.sort(seriesList, new Comparator&lt;Series&gt;() {</span>
      @Override
      public int compare(Series s1, Series s2) {
<span class="nc" id="L136">        return s1.key.compareTo(s2.key);</span>
      }
    });

<span class="nc bnc" id="L140" title="All 2 branches missed.">    for (Series ser : seriesList) {</span>
<span class="nc" id="L141">      synchronized (ser.stats) {</span>
<span class="nc" id="L142">        dataset.addSeries(toSeries(ser.key, ser.stats));</span>
<span class="nc" id="L143">      }</span>
<span class="nc" id="L144">    }</span>
<span class="nc" id="L145">  }</span>

  /**
   * The Class Series.
   */
  // a helper class that holds series and calculates an avg value
  private class Series {

    /** The key. */
    final String key;

    /** The stats. */
    final List&lt;XYDataItem&gt; stats;

    /** The avg. */
<span class="nc" id="L160">    double avg = 0;</span>

    /**
     * Instantiates a new series.
     *
     * @param en the en
     */
<span class="nc" id="L167">    Series(Map.Entry&lt;String, List&lt;XYDataItem&gt;&gt; en) {</span>
<span class="nc" id="L168">      key = en.getKey().substring(statNamePrefix.length());</span>
<span class="nc" id="L169">      stats = en.getValue();</span>
<span class="nc" id="L170">    }</span>

    /**
     * Calculate avg.
     */
    // calculating an avg value that is used for identifying the top series
    void calculateAvg() {
<span class="nc" id="L177">      long sum = 0;</span>
<span class="nc" id="L178">      int count = 1;</span>

<span class="nc" id="L180">      synchronized (stats) {</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">        boolean useMovingAvg = getMovingAvgFrame() &gt; 0 &amp;&amp; getMovingAvgFrame() &lt; stats.size();</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">        for (ListIterator&lt;XYDataItem&gt; it = stats.listIterator(); it.hasNext();) {</span>
<span class="nc" id="L184">          XYDataItem xy = it.next();</span>
<span class="nc" id="L185">          sum += xy.getY().longValue();</span>

<span class="nc bnc" id="L187" title="All 6 branches missed.">          if (useMovingAvg &amp;&amp; count % getMovingAvgFrame() == 0 || !it.hasNext()) {</span>
<span class="nc" id="L188">            double thisAvg = (double) sum / count;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (thisAvg &gt; avg) {</span>
<span class="nc" id="L190">              avg = thisAvg;</span>
            }
<span class="nc" id="L192">            sum = 0;</span>
<span class="nc" id="L193">            count = 1;</span>
<span class="nc" id="L194">          } else {</span>
<span class="nc" id="L195">            count++;</span>
          }
<span class="nc" id="L197">        }</span>
<span class="nc" id="L198">      }</span>
<span class="nc" id="L199">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>